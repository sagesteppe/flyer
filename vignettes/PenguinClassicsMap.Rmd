---
title: "PenguinClassicsMap"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PenguinClassicsMap}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r install package, eval = F}
devtools::install_github('sagesteppe/flyer')
```

The Penguin Classics map has many wonderful attributes worth emulating. 

```{r setup}
library(flyer)
library(sf)
library(dplyr)
library(ggplot2)
```

The places visited by the collectors can be loaded using `places`, and the route they took (which I made up) can be loaded via `routes``. 

```{r plot the places}
data(places)
head(places)

m <- ggplot() + 
  geom_sf(data = places)
m
```

Because the package is attached we can also just start using the data, which is currently held as a promise. 

```{r show the routes}

head(route)

route <- left_join(
  route,
  st_drop_geometry(places),
  by = c('destination' = 'location_english')
  )

m + 
  geom_sf(data = route, aes(color = date_arrive)) 

```

by default ggplot2 does not seem to order date the way I would, in the legend. 

```{r}
m + 
  geom_sf(data = route, aes(color = date_arrive)) + 
  scale_color_continuous(direction = -1)


route$date_arrive <- as.Date(route$date_arrive, format = "%m/%d%/Y")

m + 
  geom_sf(data = route, aes(color = date_arrive)) 


str(route)
```


Obviously we need some context for these data. 
Other wise they just... look the way they do above. 
We can read in some polygons which depict land from `Natural Earth`, from the `rnaturalearth` package; note that I love this packages functionality, even if I get real forgetful of their API calls (theme argument?)

```{r add land}
head(land)

m <- m + 
  geom_sf(data = route, aes(color = date_arrive)) 

m
```

While some of the data for the start end of the trip is included, such as an entry when they are near Santa Barbara and that they started and returned to Monterey, most all data focuses on the Gulf of Mexico. 
Basically, too much data would make the package too cumbersome to fit on CRAN. 

```{r subset bounding box}

bb <- st_bbox(
  c(xmin = -114, xmax = -108.5, ymin = 22.5, ymax = 30.5),
  crs = st_crs(4326)
)

m <- m  +
  coord_sf(xlim = c(bb[1], bb[3]), ylim = c(bb[2], bb[4]))

m
```

Now let's add some topography to make the land seem more natural. 
We'll also ignore the administrative borders. 

Note that we are going to go back to the drawing board to control the order which layers are added to the map.
We'll still overwrite the variable m. 

```{r add topography}

land <- st_union(land)
plot(topography)

m <- ggplot() + 
  geom_sf(data = land) + 
  geom_sf(data = topography, lwd = 0.1) + 
  geom_sf(data = places) + 
  geom_sf(data = route, aes(color = date_arrive)) +
  coord_sf(xlim = c(bb[1], bb[3]), ylim = c(bb[2], bb[4]))

```


We can the bathymetry data like this. 

```{r and bathymetry}
head(bathymetry)
plot(bathymetry)

ggplot() + 
  geom_sf(data = land, fill = '#EFDD8D') + 
  geom_sf(data = bathymetry, lwd = 0.1) + 
  geom_sf(data = topography, lwd = 0.1) + 
  geom_sf(data = places) +  
  geom_sf(data = route, aes(color = date_arrive)) +
  coord_sf(xlim = c(bb[1], bb[3]), ylim = c(bb[2], bb[4]))

```

And we can combine the scale for topography and bathymetry together like this... I will use a divergent scale which makes sense to me... 
I could see another *very* cool interpretation of using a continuous and counting everything from 0 at 4300 feet and adding the difference to the 'topography' data set. 

```{r}

```


Or, and much to my liking, we can convert the polylines of bathymetry to polygons, and use them to color the whole ocean!
With darker areas being deeper hues of blue. 
