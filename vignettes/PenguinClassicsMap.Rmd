---
title: "Exploring the Data sets"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DataSetsExpose}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction and quick start 

flyer is available on github, and should go to CRAN sometime. 
It can be installed via either of  the following commands. 

```{r install package, eval = F}
install.packages('devtools')
devtools::install_github('sagesteppe/flyer')

# remotes is very similar and a good alternative for this use case.
install.packages('remotes') 
remotes::install_github('sagesteppe/flyer')
```

To explore the data we will load a couple packages for interacting with the data (sf, dplyr), and a whole slew of packages for plotting the data using ggplot2 (ggnewscale, ggrepel). 
It might seem onerous to be installing all of these packages, but I bet once you see what they do you'll be quite excited to have them. 

```{r setup}
library(flyer)
library(sf)
library(dplyr)
library(ggplot2)
library(ggnewscale)
library(ggrepel)
```

We'll modify the number of graticules right off the bat, note that the `pretty` function does not always return the requested `n`, so... 

```{r define a carto ggplot theme}

graticNo <- function(polygon, nx, ny){
  
  bb <- round(st_bbox(polygon), 1)
  if(all(missing(nx) & missing(ny))) {nx <- 5;ny <- 5} else {
    if(all(missing(nx) & ! missing(ny))) {nx <- ny} else {
      if(all(missing(ny) & ! missing(nx))) {ny <- nx}
    } 
  } 

  xbreaks <- pretty(seq(bb[1], bb[3], length.out = nx), nx)
  ybreaks <- pretty(seq(bb[2], bb[4], length.out = ny), ny)
  
  return(
    list(
      x = xbreaks, y = ybreaks
    )
  )
}

brks <- graticNo(polygon = places, nx = 4, ny = 5)

```

# the data sets 

The places visited by the collectors can be loaded using `places`, and the route they took (which I made up) can be loaded via `routes``. 

```{r plot the places}
data(places)
head(places)

m <- ggplot() + 
  geom_sf(data = places)
```

The places seem like they will be better treated as text labels - we can apply them with `ggrepel::geom_text_repel` which will move them to avoid conflicts with other plot elements. 

```{r}
m <- ggplot() +
  
  ggrepel::geom_text_repel(
    data = places,
    aes(label = location_espanol, geometry = geometry),
    stat = "sf_coordinates",
    size = 3
    ) + 
  
  # now let's add in our customized graticules too. 
  scale_x_continuous('Longitude', breaks = brks$x) +
  scale_y_continuous('Latitude', breaks = brks$y) + 
  theme_linedraw()

m
```

Because the package is attached we can also just start using the data, which is currently held as a promise. 
In other words we don't need to call `data(object)` on the data sets, we can just use them directly - such as viewing them by calling `head(object)`. 

```{r show the routes}
head(route)

route <- left_join(
  route,
  st_drop_geometry(places),
  by = c('destination' = 'location_english')
  )

m + 
  geom_sf(data = route, aes(color = date_arrive)) 
```

By default ggplot2 does not seem to order Date variables the way I would. 
We can convert the dates to factor to enforce this. 

```{r}
m + 
  geom_sf(data = route, aes(color = date_arrive))
```

Obviously we need some context for these data. 
Other wise they just... look the way they do above. 
We can read in some polygons which depict land from `Natural Earth`, from the `rnaturalearth` package; note that I love this packages functionality, even if I get real forgetful of their API calls (theme argument?)

```{r add land}
head(land)

m <- m + 
  geom_sf(data = route, aes(color = date_arrive)) 

m
```

While some of the data for the start end of the trip is included, such as an entry when they are near Santa Barbara and that they started and returned to Monterey, most all data focuses on the Gulf of Mexico. 
Basically, too much data would make the package too cumbersome to fit on CRAN. 

```{r subset bounding box}

bb <- st_bbox(
  c(xmin = -114, xmax = -108.5, ymin = 22.5, ymax = 30.5),
  crs = st_crs(4326)
)

m <- m  +
  coord_sf(xlim = c(bb[1], bb[3]), ylim = c(bb[2], bb[4]))

m
```

Now let's add some topography to make the land seem more natural. 
We'll also ignore the administrative borders. 

Note that we are going to go back to the drawing board to control the order which layers are added to the map.
We'll still overwrite the variable m. 

```{r add topography}
land <- st_union(land)
plot(topography)

m <- ggplot() + 
  geom_sf(data = land) + 
  geom_sf(data = topography, lwd = 0.1) + 
  geom_sf(data = places) + 
  geom_sf(data = route, aes(color = date_arrive)) +
  coord_sf(xlim = c(bb[1], bb[3]), ylim = c(bb[2], bb[4]))

m
```


We can the bathymetry data like this. 

```{r and bathymetry}
head(bathymetry)
plot(bathymetry)

ggplot() + 
  geom_sf(data = land, fill = '#EFDD8D') + 
  geom_sf(data = bathymetry, aes(color = elevation), lwd = 0.1) + 
  geom_sf(data = topography,  aes(color = elevation), lwd = 0.1) + 
  geom_sf(data = places) +  
 # geom_sf(data = route, aes(color = date_arrive)) +
  coord_sf(xlim = c(bb[1], bb[3]), ylim = c(bb[2], bb[4]))

```

And we can combine the scale for topography and bathymetry together like this... I will use a divergent scale which makes sense to me... 
I could see another *very* cool interpretation of using a continuous and counting everything from 0 at 4300 feet and adding the difference to the 'topography' data set. 

```{r}

```


Or, and much to my liking, we can convert the polylines of bathymetry to polygons, and use them to color the whole ocean!
With darker areas being deeper hues of blue. 
